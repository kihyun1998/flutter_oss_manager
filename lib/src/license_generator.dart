import 'dart:convert';
import 'dart:io';

import 'package:flutter_oss_manager/src/known_licenses_data.dart';
import 'package:path/path.dart' as p;
import 'package:yaml/yaml.dart';

import '../oss_licenses.dart';

class LicenseGenerator {
  final Map<String, String> _knownLicenses = knownLicensesData;
  static const List<String> _licenseFileNames = [
    'LICENSE',
    'LICENSE.txt',
    'COPYING',
    'COPYING.txt',
    'LICENCE',
    'LICENCE.txt',
  ];

  String _readLicenseFile(String filePath) {
    return File(filePath).readAsStringSync();
  }

  Set<String> _tokenize(String text) {
    return text
        .toLowerCase()
        .split(RegExp(r'[^a-z0-9]+'))
        .where((s) => s.isNotEmpty)
        .toSet();
  }

  double _calculateJaccardSimilarity(Set<String> set1, Set<String> set2) {
    if (set1.isEmpty && set2.isEmpty) return 1.0;
    if (set1.isEmpty || set2.isEmpty) return 0.0;

    final intersection = set1.intersection(set2).length;
    final union = set1.union(set2).length;

    return intersection / union;
  }

  String _normalizeText(String text) {
    // Remove copyright lines and email addresses
    text = text.replaceAll(
        RegExp(r'copyright \(c\) .+', caseSensitive: false, multiLine: true),
        '');
    text = text.replaceAll(
        RegExp(r'<[^>]+>'), ''); // Remove text in angle brackets like emails
    // Standardize whitespace
    text = text.replaceAll(RegExp(r'\s+'), ' ').trim();
    return text;
  }

  String? _runHeuristics(String licenseContent) {
    final lowerCaseText = licenseContent.toLowerCase();

    // MIT Heuristic
    if (lowerCaseText.contains('permission is hereby granted') &&
        lowerCaseText.contains('the software is provided "as is"')) {
      return 'MIT';
    }
    // BSD-3-Clause Heuristic
    if (lowerCaseText
            .contains('redistribution and use in source and binary forms') &&
        lowerCaseText.contains(
            'neither the name of the copyright holder nor the names of its contributors may be used')) {
      return 'BSD-3-Clause';
    }
    // Apache 2.0 Heuristic
    if (lowerCaseText.contains('apache license, version 2.0') &&
        lowerCaseText.contains(
            'terms and conditions for use, reproduction, and distribution')) {
      return 'Apache-2.0';
    }
    // ISC Heuristic
    if (lowerCaseText.contains(
        'permission to use, copy, modify, and/or distribute this software for any purpose')) {
      return 'ISC';
    }

    return null;
  }

  String _summarizeLicense(String licenseContent) {
    // Step 1: Run conservative heuristics for a quick and accurate match.
    final heuristicMatch = _runHeuristics(licenseContent);
    if (heuristicMatch != null) {
      return heuristicMatch;
    }

    // Step 2: If no heuristic match, proceed with paragraph-based similarity.
    final scannedParagraphs = _normalizeText(licenseContent)
        .split(RegExp(r'\n\s*\n'))
        .where((p) => p.isNotEmpty)
        .toList();
    if (scannedParagraphs.isEmpty) {
      return 'Unknown';
    }

    String bestMatch = 'Unknown';
    double highestAverageSimilarity = 0.0;

    for (final knownLicenseEntry in _knownLicenses.entries) {
      final templateParagraphs = _normalizeText(knownLicenseEntry.value)
          .split(RegExp(r'\n\s*\n'))
          .where((p) => p.isNotEmpty)
          .toList();
      if (templateParagraphs.isEmpty) {
        continue;
      }

      final templateParagraphTokens =
          templateParagraphs.map(_tokenize).toList();
      double totalSimilarity = 0;

      for (final scannedParagraph in scannedParagraphs) {
        final scannedTokens = _tokenize(scannedParagraph);
        double maxSimilarityForParagraph = 0;

        for (final templateTokens in templateParagraphTokens) {
          final similarity =
              _calculateJaccardSimilarity(scannedTokens, templateTokens);
          if (similarity > maxSimilarityForParagraph) {
            maxSimilarityForParagraph = similarity;
          }
        }
        totalSimilarity += maxSimilarityForParagraph;
      }

      final averageSimilarity = totalSimilarity / scannedParagraphs.length;

      if (averageSimilarity > highestAverageSimilarity) {
        highestAverageSimilarity = averageSimilarity;
        bestMatch = knownLicenseEntry.key;
      }
    }

    // Step 4: Final determination based on the new threshold.
    if (highestAverageSimilarity > 0.5) {
      return bestMatch;
    }

    return 'Unknown';
  }

  void _writeDartFile(String outputPath, List<OssLicense> ossLicenses) {
    final output = File(outputPath);
    final buffer = StringBuffer();

    buffer.writeln(
        '// This file is generated by flutter_oss_manager. Do not modify.');
    buffer.writeln('');
    buffer.writeln('class OssLicense {');
    buffer.writeln('  final String name;');
    buffer.writeln('  final String version;');
    buffer.writeln('  final String licenseText;');
    buffer.writeln('  final String licenseSummary;');
    buffer.writeln('  final String? repositoryUrl;');
    buffer.writeln('  final String? description;');
    buffer.writeln('');
    buffer.writeln('  const OssLicense({');
    buffer.writeln('    required this.name,');
    buffer.writeln('    required this.version,');
    buffer.writeln('    required this.licenseText,');
    buffer.writeln('    required this.licenseSummary,');
    buffer.writeln('    this.repositoryUrl,');
    buffer.writeln('    this.description,');
    buffer.writeln('  });');
    buffer.writeln('}');
    buffer.writeln('');
    buffer.writeln('const List<OssLicense> ossLicenses = [');
    for (final license in ossLicenses) {
      buffer.writeln('  OssLicense(');
      buffer.writeln('    name: ${jsonEncode(license.name)},');
      buffer.writeln('    version: ${jsonEncode(license.version)},');
      buffer.writeln('    licenseText: ${jsonEncode(license.licenseText)},');
      buffer.writeln(
          '    licenseSummary: ${jsonEncode(license.licenseSummary)},');
      buffer
          .writeln('    repositoryUrl: ${jsonEncode(license.repositoryUrl)},');
      buffer.writeln('    description: ${jsonEncode(license.description)},');
      buffer.writeln('  ),');
    }
    buffer.writeln('];');

    output.writeAsStringSync(buffer.toString());
    print('Generated Dart file: $outputPath');
  }

  void generateLicenses({String? licenseFilePath, String? outputFilePath}) {
    if (licenseFilePath == null) {
      print(
          'Error: License file path must be provided for the generate command.');
      return;
    }
    final licenseContent = _readLicenseFile(licenseFilePath);
    final licenseSummary = _summarizeLicense(licenseContent);

    final license = OssLicense(
      name: p.basenameWithoutExtension(licenseFilePath),
      version: 'N/A',
      licenseText: licenseContent,
      licenseSummary: licenseSummary,
    );

    _writeDartFile(outputFilePath ?? 'lib/oss_licenses.dart', [license]);
  }

  Future<void> scanPackages({String? outputFilePath}) async {
    print('Scanning packages for licenses...');
    final pubspecLockFile =
        File(p.join(Directory.current.path, 'pubspec.lock'));
    if (!pubspecLockFile.existsSync()) {
      print('Error: pubspec.lock not found. Run \'flutter pub get\' first.');
      return;
    }
    final pubspecLockContent = pubspecLockFile.readAsStringSync();
    final pubspecLockMap = loadYaml(pubspecLockContent) as YamlMap;

    final List<OssLicense> collectedLicenses = [];

    final packages = pubspecLockMap['packages'] as YamlMap?;
    if (packages != null) {
      for (final entry in packages.entries) {
        final packageName = entry.key.toString();
        final packageInfo = entry.value as YamlMap;
        final source = packageInfo['source'].toString();

        OssLicense? license;
        if (source == 'hosted') {
          final packageVersion = packageInfo['version'].toString();
          print('- $packageName ($packageVersion) [hosted]');
          license =
              await _findAndSummarizeHostedLicense(packageName, packageVersion);
        } else if (source == 'sdk') {
          print('- $packageName [sdk]');
          license = await _findAndSummarizeSdkLicense(packageName);
        } else {
          print('- $packageName [unknown source: $source]');
        }

        if (license != null) {
          collectedLicenses.add(license);
        }
      }
    }

    if (outputFilePath != null) {
      _writeDartFile(
          p.join(Directory.current.path, outputFilePath), collectedLicenses);
    } else {
      print('No output file path provided. Skipping .dart file generation.');
    }
  }

  Future<OssLicense?> _findAndSummarizeHostedLicense(
      String packageName, String packageVersion) async {
    final pubCacheDir = _getPubCacheDir();
    final packagePath = p.join(
        pubCacheDir, 'hosted', 'pub.dev', '$packageName-$packageVersion');

    String? repositoryUrl;
    String? description;
    final packagePubspecFile = File(p.join(packagePath, 'pubspec.yaml'));
    if (packagePubspecFile.existsSync()) {
      final packagePubspecContent = packagePubspecFile.readAsStringSync();
      final packageYamlMap = loadYaml(packagePubspecContent) as YamlMap;
      repositoryUrl = packageYamlMap['repository']?.toString() ??
          packageYamlMap['homepage']?.toString();
      description = packageYamlMap['description']?.toString();
    }

    for (final fileName in _licenseFileNames) {
      final licenseFilePath = p.join(packagePath, fileName);
      final licenseFile = File(licenseFilePath);
      if (licenseFile.existsSync()) {
        final licenseContent = licenseFile.readAsStringSync();
        final licenseSummary = _summarizeLicense(licenseContent);
        return OssLicense(
            name: packageName,
            version: packageVersion,
            licenseText: licenseContent,
            licenseSummary: licenseSummary,
            repositoryUrl: repositoryUrl,
            description: description);
      }
    }
    print('  No license file found for $packageName');
    return null;
  }

  Future<OssLicense?> _findAndSummarizeSdkLicense(String packageName) async {
    final flutterSdkPath = await _getFlutterSdkPath();
    if (flutterSdkPath == null) {
      print('  Flutter SDK path not found.');
      return null;
    }

    final licenseFilePath = p.join(flutterSdkPath, 'LICENSE');
    final licenseFile = File(licenseFilePath);

    String? repositoryUrl;
    String? description;
    String sdkVersion = '0.0.0';

    try {
      final result = await Process.run(
          Platform.isWindows ? 'flutter.bat' : 'flutter',
          ['--version', '--machine']);
      if (result.exitCode == 0) {
        final jsonOutput = jsonDecode(result.stdout.toString());
        sdkVersion = jsonOutput['frameworkVersion'];
      }
    } catch (e) {
      print('Error getting Flutter SDK version: $e');
    }

    if (packageName == 'flutter') {
      repositoryUrl = 'https://github.com/flutter/flutter';
      description = 'Flutter SDK';
    } else if (packageName == 'flutter_test') {
      repositoryUrl =
          'https://github.com/flutter/flutter/tree/master/packages/flutter_test';
      description = 'Flutter Test Framework';
    } else if (packageName == 'sky_engine') {
      repositoryUrl = 'https://github.com/flutter/engine';
      description = 'Flutter Engine Sky Engine';
    }

    if (licenseFile.existsSync()) {
      final licenseContent = licenseFile.readAsStringSync();
      final licenseSummary = _summarizeLicense(licenseContent);
      return OssLicense(
          name: packageName,
          version: sdkVersion,
          licenseText: licenseContent,
          licenseSummary: licenseSummary,
          repositoryUrl: repositoryUrl,
          description: description);
    }
    print('  No license file found for SDK package: $packageName');
    return null;
  }

  String _getPubCacheDir() {
    if (Platform.isWindows) {
      return p.join(Platform.environment['LOCALAPPDATA']!, 'Pub', 'Cache');
    } else {
      return p.join(Platform.environment['HOME']!, '.pub-cache');
    }
  }

  Future<String?> _getFlutterSdkPath() async {
    try {
      final executable = Platform.isWindows ? 'flutter.bat' : 'flutter';
      final result = await Process.run(executable, ['--version', '--machine']);
      if (result.exitCode == 0) {
        final jsonOutput = jsonDecode(result.stdout.toString());
        return jsonOutput['flutterRoot'];
      }
    } catch (e) {
      print('Error getting Flutter SDK path: $e');
    }
    return null;
  }
}
