import 'dart:io';
import 'dart:math';
import 'dart:convert'; // Import for jsonEncode
import 'package:yaml/yaml.dart';
import 'package:path/path.dart' as p; // Import path package
import 'dart:isolate'; // Import Isolate
import 'package:flutter_oss_manager/src/known_licenses_data.dart'; // Import known licenses data

class OssLicense {
  final String name;
  final String version;
  final String licenseText;
  final String licenseSummary;
  final String? repositoryUrl;
  final String? description;

  const OssLicense({
    required this.name,
    required this.version,
    required this.licenseText,
    required this.licenseSummary,
    this.repositoryUrl,
    this.description,
  });
}

class LicenseGenerator {
  final Map<String, String> _knownLicenses = knownLicensesData; // Initialize directly
  static const List<String> _licenseFileNames = [
    'LICENSE',
    'LICENSE.txt',
    'COPYING',
    'COPYING.txt',
    'LICENCE',
    'LICENCE.txt',
  ];

  // Removed _loadKnownLicenses() method

  String _readLicenseFile(String filePath) {
    final file = File(filePath);
    return file.readAsStringSync();
  }

  Set<String> _tokenize(String text) {
    // Simple tokenization: convert to lowercase and split by non-alphanumeric characters
    return text.toLowerCase().split(RegExp(r'[^a-z0-9]+')).where((s) => s.isNotEmpty).toSet();
  }

  double _calculateJaccardSimilarity(String text1, String text2) {
    final set1 = _tokenize(text1);
    final set2 = _tokenize(text2);

    if (set1.isEmpty && set2.isEmpty) {
      return 1.0; // Both empty, considered identical
    }
    if (set1.isEmpty || set2.isEmpty) {
      return 0.0; // One empty, one not, considered dissimilar
    }

    final intersection = set1.intersection(set2).length;
    final union = set1.union(set2).length;

    return intersection / union;
  }

  void _writeDartFile(String outputPath, List<OssLicense> ossLicenses) {
    final output = File(outputPath);
    final buffer = StringBuffer();

    buffer.writeln('// This file is generated by flutter_oss_manager. Do not modify.');
    buffer.writeln('');
    buffer.writeln('class OssLicense {');
    buffer.writeln('  final String name;');
    buffer.writeln('  final String version;');
    buffer.writeln('  final String licenseText;');
    buffer.writeln('  final String licenseSummary;');
    buffer.writeln('  final String? repositoryUrl;');
    buffer.writeln('  final String? description;');
    buffer.writeln('');
    buffer.writeln('  const OssLicense({');
    buffer.writeln('    required this.name,');
    buffer.writeln('    required this.version,');
    buffer.writeln('    required this.licenseText,');
    buffer.writeln('    required this.licenseSummary,');
    buffer.writeln('    this.repositoryUrl,');
    buffer.writeln('    this.description,');
    buffer.writeln('  });');
    buffer.writeln('}');
    buffer.writeln('');
    buffer.writeln('const List<OssLicense> ossLicenses = [');
    for (final license in ossLicenses) {
      buffer.writeln('  OssLicense(');
      buffer.writeln('    name: ' + jsonEncode(license.name) + ',');
      buffer.writeln('    version: ' + jsonEncode(license.version) + ',');
      buffer.writeln('    licenseText: ' + jsonEncode(license.licenseText) + ',');
      buffer.writeln('    licenseSummary: ' + jsonEncode(license.licenseSummary) + ',');
      buffer.writeln('    repositoryUrl: ' + jsonEncode(license.repositoryUrl) + ',');
      buffer.writeln('    description: ' + jsonEncode(license.description) + ',');
      buffer.writeln('  ),');
    }
    buffer.writeln('];');

    output.writeAsStringSync(buffer.toString());
    print('Generated Dart file: $outputPath');
  }

  void generateLicenses({String? licenseFilePath, String? outputFilePath}) {
    print('Generating licenses...');
    if (licenseFilePath != null) {
      final licenseContent = _readLicenseFile(licenseFilePath);
      print('License content:\n$licenseContent');

      String bestMatch = 'Unknown';
      double highestSimilarity = 0.0;

      for (final entry in _knownLicenses.entries) {
        final similarity = _calculateJaccardSimilarity(licenseContent, entry.value);
        print('Similarity with ${entry.key}: ${similarity.toStringAsFixed(4)}');
        if (similarity > highestSimilarity) {
          highestSimilarity = similarity;
          bestMatch = entry.key;
        }
      }

      String licenseSummary = 'Unknown';
      if (highestSimilarity > 0.7) { // Adjust threshold as needed
        licenseSummary = bestMatch;
        print('License summary: $bestMatch (Similarity: ${highestSimilarity.toStringAsFixed(4)})');
      } else {
        print('License summary: Unknown (No confident match found. Highest similarity: ${highestSimilarity.toStringAsFixed(4)})');
      }

      if (outputFilePath != null) {
        _writeDartFile(outputFilePath, [OssLicense(name: 'Manual License', version: '0.0.0', licenseText: licenseContent, licenseSummary: licenseSummary, repositoryUrl: null, description: null)]);
      } else {
        print('No output file path provided. Skipping .dart file generation.');
      }
    } else {
      print('No license file path provided.');
    }
  }

  Future<void> scanPackages({String? outputFilePath}) async {
    print('Scanning packages for licenses...');
    final pubspecFile = File('pubspec.yaml');
    if (!pubspecFile.existsSync()) {
      print('Error: pubspec.yaml not found in the current directory.');
      return;
    }

    final pubspecContent = pubspecFile.readAsStringSync();
    final yamlMap = loadYaml(pubspecContent) as YamlMap;

    final pubspecLockFile = File('pubspec.lock');
    if (!pubspecLockFile.existsSync()) {
      print('Error: pubspec.lock not found in the current directory. Run \'flutter pub get\' first.');
      return;
    }
    final pubspecLockContent = pubspecLockFile.readAsStringSync();
    final pubspecLockMap = loadYaml(pubspecLockContent) as YamlMap;

    final List<OssLicense> collectedLicenses = [];

    final packages = pubspecLockMap['packages'] as YamlMap?;
    if (packages != null) {
      for (final entry in packages.entries) {
        final packageName = entry.key.toString();
        final packageInfo = entry.value as YamlMap;
        final source = packageInfo['source'].toString();

        OssLicense? license;
        if (source == 'hosted') {
          final packageVersion = packageInfo['version'].toString();
          print('- $packageName ($packageVersion) [hosted]');
          license = await _findAndSummarizeHostedLicense(packageName, packageVersion);
        } else if (source == 'sdk') {
          print('- $packageName [sdk]');
          license = await _findAndSummarizeSdkLicense(packageName);
        } else {
          print('- $packageName [unknown source: $source]');
        }

        if (license != null) {
          collectedLicenses.add(license);
        }
      }
    }

    if (outputFilePath != null) {
      _writeDartFile(outputFilePath, collectedLicenses);
    } else {
      print('No output file path provided. Skipping .dart file generation.');
    }
  }

  String? _getPackageVersionFromLockfile(YamlMap pubspecLockMap, String packageName) {
    final packages = pubspecLockMap['packages'] as YamlMap?;
    if (packages != null && packages.containsKey(packageName)) {
      final packageInfo = packages[packageName] as YamlMap?;
      if (packageInfo != null && packageInfo.containsKey('version')) {
        return packageInfo['version'].toString();
      }
    }
    return null;
  }

  Future<OssLicense?> _findAndSummarizeHostedLicense(String packageName, String packageVersion) async {
    final pubCacheDir = Platform.environment['LOCALAPPDATA']! + '\\Pub\\Cache';
    final packagePath = '$pubCacheDir\\hosted\\pub.dev\\$packageName-$packageVersion';
    print('  Searching for license in: $packagePath');

    String? repositoryUrl;
    String? description;
    final packagePubspecFile = File('$packagePath\\pubspec.yaml');
    if (packagePubspecFile.existsSync()) {
      final packagePubspecContent = packagePubspecFile.readAsStringSync();
      final packageYamlMap = loadYaml(packagePubspecContent) as YamlMap;
      repositoryUrl = packageYamlMap['repository']?.toString() ?? packageYamlMap['homepage']?.toString(); // Prioritize repository
      description = packageYamlMap['description']?.toString();
    }

    final searchPaths = [
      packagePath,
      '$packagePath\\lib',
      '$packagePath\\doc',
    ];

    for (final path in searchPaths) {
      for (final fileName in _licenseFileNames) {
        final licenseFilePath = '$path\\$fileName';
        final licenseFile = File(licenseFilePath);
        if (licenseFile.existsSync()) {
          final licenseContent = licenseFile.readAsStringSync();
          String bestMatch = 'Unknown';
          double highestSimilarity = 0.0;

          for (final entry in _knownLicenses.entries) {
            final similarity = _calculateJaccardSimilarity(licenseContent, entry.value);
            if (similarity > highestSimilarity) {
              highestSimilarity = similarity;
              bestMatch = entry.key;
            }
          }

          String licenseSummary = 'Unknown';
          if (highestSimilarity > 0.7) {
            licenseSummary = bestMatch;
          }
          return OssLicense(name: packageName, version: packageVersion, licenseText: licenseContent, licenseSummary: licenseSummary, repositoryUrl: repositoryUrl, description: description);
        }
      }
    }
    print('  No license file found for $packageName');
    return null;
  }

  Future<String?> _getFlutterSdkPath() async {
    try {
      final executable = Platform.isWindows ? 'flutter.bat' : 'flutter';
      final result = await Process.run(executable, ['--version', '--machine']);
      if (result.exitCode == 0) {
        final jsonOutput = jsonDecode(result.stdout.toString());
        return jsonOutput['flutterRoot'];
      }
    } catch (e) {
      print('Error getting Flutter SDK path: $e');
    }
    return null;
  }

  Future<OssLicense?> _findAndSummarizeSdkLicense(String packageName) async {
    final flutterSdkPath = await _getFlutterSdkPath();
    if (flutterSdkPath == null) {
      print('  Flutter SDK path not found.');
      return null;
    }

    final licenseFilePath = '$flutterSdkPath\\LICENSE';
    final licenseFile = File(licenseFilePath);

    String? repositoryUrl;
    String? description;
    String sdkVersion = '0.0.0'; // Default SDK version

    try {
      final result = await Process.run(Platform.isWindows ? 'flutter.bat' : 'flutter', ['--version', '--machine']);
      if (result.exitCode == 0) {
        final jsonOutput = jsonDecode(result.stdout.toString());
        sdkVersion = jsonOutput['frameworkVersion'];
      }
    } catch (e) {
      print('Error getting Flutter SDK version: $e');
    }

    if (packageName == 'flutter') {
      repositoryUrl = 'https://github.com/flutter/flutter';
      description = 'Flutter SDK';
    } else if (packageName == 'flutter_test') {
      repositoryUrl = 'https://github.com/flutter/flutter/tree/master/packages/flutter_test';
      description = 'Flutter Test Framework';
    } else if (packageName == 'sky_engine') {
      repositoryUrl = 'https://github.com/flutter/engine';
      description = 'Flutter Engine Sky Engine';
    }

    if (licenseFile.existsSync()) {
      final licenseContent = licenseFile.readAsStringSync();
      String bestMatch = 'Unknown';
      double highestSimilarity = 0.0;

      for (final entry in _knownLicenses.entries) {
        final similarity = _calculateJaccardSimilarity(licenseContent, entry.value);
        if (similarity > highestSimilarity) {
          highestSimilarity = similarity;
          bestMatch = entry.key;
        }
      }

      String licenseSummary = 'Unknown';
      if (highestSimilarity > 0.7) {
        licenseSummary = bestMatch;
      }
      return OssLicense(name: packageName, version: sdkVersion, licenseText: licenseContent, licenseSummary: licenseSummary, repositoryUrl: repositoryUrl, description: description);
    }
    print('  No license file found for SDK package: $packageName');
    return null;
  }
}